/*!            Script - программа логических процедурных знаний

Script - это откомпилированная программа логических процедурных знаний.
Непосредственно парсингом исходных текстов скрипта занимается модуль Compile. 

Скрипт Script состоит из блока Code (набора команд Command)
и массива определений функций Function (встроенных и заданных пользователем).
Команда Command может быть простым выражением Expr, оператором вывода out,
выходом из функции return, условным оператором if, циклом for и т.д.

Выражение - это деревесная структура. Её узлы являются наследниками Expr
и могут быть следующих видов: ExprConst - константа, ExprVar - указатель на переменную,
ExprOp - бинарная операция типа x & y, ExprFun - вычисление функции name(expr1,expr2,...)

Переменные внутри блока кода Code считаются локальными, если не встречалось
переменных с таким же именем в блоке выше, но не выше тела функции.
Т.е. глобальных переменных, доступных внутри функции, нет, кроме предопределённого GRAPH.

Все выражения, переменные и функции имеют полиморфное значение Value (Value.h).
Объявленные в модуле классы:

class Script;                // Скрипт логических процедурных знаний

                             (с) 2018-sep: steps: synset.com, absolutist.com, qudata.com
****************************************************************************************/
#ifndef ScriptH
#define ScriptH
#include "OTypes.h"          // Определение базовых типов
#include "Logic.h"           // Вероятностная логика
#include "Value.h"           // Полиморфные переменные
#include "Graph.h"           // Граф с вероятностными рёбрми
#include "Source.h"          // Исходник скрипта
#include "Trace.h"           // Исходник скрипта

#include <ctime>             // Системное время
#include <iomanip>           // setw

#define _DS_CHECK_POINTER  1 // проводится проверка указателей (отключаем в run)
#define _DS_CHECK_TYPE     1 // проводится проверка типов      (отключаем в run)
#define _DS_CHECK_RANGE    1 // проводится проверка диапазонов (отключаем в run)

#include "Code.h"

//=======================================================================================
// Предварительное объявление классов:
SPTR_DEF(Script)             // Скрипт
SPTR_WDEF(Script)            // Скрипт
SPTR_DEF(Value)              // Значение
SPTR_DEF(Function)           // Функции скрипта

//=======================================================================================
//! Скрипт логических процедурных знаний
/*!
Скрипт состоит из последовательности набора команд Code и определений функций
*/
class Script: SPTR_ENABLE_FROM_THIS(Script)
{
public:
   Value*             _graph;      //!< граф объектов и отношений между ними
   CodePtr            _code;       //!< базовый список команд вне функций (main)
   vector<FunctionPtr>_functions;  //!< список всех функций
   bool               _listing;    //!< вывести результат компиляции
   Int                _trace;      //!< провести трассировку кода
   clock_t            _time_start; //!< время начала работы скрипта
   ofstream           _fout;       //!< вывод в текстовый файл

   Script();
   ~Script();
   enum ScriptState {
      ST_IDLE,          //!< ничего не происходит
      ST_PARSING,       //!< идет парсинг файлов
      ST_RUN,           //!< идет выполнение кода
      ST_COMPLETE       //!< выполнение кода завершено
   };
   /*!
      Получить текущий экземпляр скрипта
   */
   static ScriptPtr instance() { return _instance.lock(); }
   /*!
   Инициализировать скрипт
   */
   void init();
   //! Загрузить скрипт из файла
   /*!
   Загрузить скрипт из файла
   \param  fileName имя файла
   \param  fileDir путь к текущей директории
   \return main если истина, то это запускаемый скрипт иначе подключенный через #include модуль
   */
   bool load(const string &fileName, const string fileDir = "", bool main = true);
   //! Запустить скрипт на выполнение
   Value run();
   //! Получить указатель на функцию-демона с именем name
   FunctionPtr get_function(const string &name);
   //! Добавить новую функцию \todo (проверить дубляж)
   void add_function(FunctionPtr fun) { _functions.push_back(fun); }
   //!  Вывести в поток out скрипт scr в виде текста (программы)
   ostream& print(ostream& out);
   /*!
   Регистрируем исходник
   \param fileName имя или путь к файлу
   \param fileDir путь к текущей директории
   \return идентификатор исходника
   */
   size_t registerSource(const string& fileName, const string fileDir = "");
   /*!
   Получить короткое имя файла с исходниками
   \param sourceID идентификатор исходника
   \return короткое имя файла с исходниками
   */
   string srcShortFileName(size_t sourceID);
   /*!
   Получить полный путь к файлу с исходниками
   \param sourceID идентификатор исходника
   \return полный путь к файлу с исходниками
   */
   string srcFilePath(size_t sourceID);
   /*!
   Получить путь к директории в которой расположен файл с исходниками
   \param sourceID идентификатор исходника
   \return путь к директории в которой расположен файл с исходниками
   */
   string srcFileDir(size_t sourceID);
   /*!
   Получить идентификатор исходника по имени файла
   \param fileName имя или путь к файлу
   \param[out] sourceID идентификатор исходника
   \return найден ли файл с исходником
   */
   bool srcID(const string &fileName, size_t &sourceID);
   /*!
   Получить число исходников
   \return число исходников
   */
   size_t srcSize() { return _sources.size(); }
   /*!
   Установить новое состояние скрипта
   \param newState новое состояние скрипта
   */
   void state(ScriptState newState) { _state = newState; }
   /*!
   Получить текущее состояние скрипта
   \param текущее состояние скрипта
   */
   ScriptState state() { return _state; }
   /*!
   Получить идентификатор исходника, который парсится в текущий момент
   \param Идентификатор исходника, который парсится в текущий момент
   */
   size_t parseSourceID() { return _parseSourceID; }
   /*!
   Получить рабочую директорию проекта
   \return рабочая директория проекта
   */
   string workDir();
   /*!
   Получить полный путь к файлу в рабочей директории
   \return полный путь к файлу в рабочей директории
   */
   string workPath(string &fileName);
   /*!
   Добавить функцию с проверкой уникатольности имени
   \param f указатель на функцию
   \return удалось ли добавить функцию?
   */
   bool addFunction(FunctionPtr f);
private:  
   //=======================================================================================
   //! Стек хранения идентификаторов файлов, которые парсятся в текущий момент
   class ParseStack
   {
   public:
      ParseStack(Script *script, size_t sourceID);
      ~ParseStack();
   private:
      Script* _script;                 //!< ссылка на текущий скрипт
      size_t  _prevParseSourceID;      //!< предыдущий файл, который восстанавливаем в деструкторе
   };
   vector<Source> _sources;            //!< исходники скрипта
   ScriptState    _state = ST_IDLE;    //!< текущее состояние скрипта
   size_t         _parseSourceID = 0;  //!< идентификатор исходника, который парсится в текущий момент
   static ScriptWPtr _instance;        //!< экземпляр скрипта   
};

//=======================================================================================
#endif
